// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Culori from "./Culori.res.mjs";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as ColorAnalysis from "./ColorAnalysis.res.mjs";

function paletteStyleToString(style) {
  if (style === "minimal") {
    return "minimal";
  } else if (style === "warm") {
    return "warm";
  } else if (style === "vibrant") {
    return "vibrant";
  } else if (style === "professional") {
    return "professional";
  } else {
    return "cool";
  }
}

function generateFallbackStyleDictionary(baseColor) {
  return {
          color: {
            primary: Js_dict.fromArray([
                  [
                    "50",
                    {
                      value: baseColor
                    }
                  ],
                  [
                    "100",
                    {
                      value: baseColor
                    }
                  ],
                  [
                    "200",
                    {
                      value: baseColor
                    }
                  ],
                  [
                    "300",
                    {
                      value: baseColor
                    }
                  ],
                  [
                    "400",
                    {
                      value: baseColor
                    }
                  ],
                  [
                    "500",
                    {
                      value: baseColor
                    }
                  ],
                  [
                    "600",
                    {
                      value: baseColor
                    }
                  ],
                  [
                    "700",
                    {
                      value: baseColor
                    }
                  ],
                  [
                    "800",
                    {
                      value: baseColor
                    }
                  ],
                  [
                    "900",
                    {
                      value: baseColor
                    }
                  ]
                ]),
            secondary: Js_dict.fromArray([[
                    "500",
                    {
                      value: baseColor
                    }
                  ]]),
            neutral: Js_dict.fromArray([[
                    "500",
                    {
                      value: "#6b7280"
                    }
                  ]]),
            semantic: undefined
          }
        };
}

function analyzeStyleDictionaryAccessibility(tokens, request) {
  var issues = [];
  var wcagCompliance = "AA";
  var primaryToken = Js_dict.get(tokens.color.primary, "500");
  if (primaryToken !== undefined) {
    var primaryColor = Caml_option.valFromOption(primaryToken).value;
    var accessibilityWhite = ColorAnalysis.validateAccessibility(primaryColor, "#FFFFFF", undefined, undefined);
    var accessibilityBlack = ColorAnalysis.validateAccessibility(primaryColor, "#000000", undefined, undefined);
    var maxContrast = Math.max(accessibilityWhite.contrast, accessibilityBlack.contrast);
    if (maxContrast < 4.5) {
      issues.push("Primary color may have insufficient contrast for text");
      wcagCompliance = "partial";
    }
    var context = request.context;
    if (context !== undefined) {
      var match = context.accessibility;
      if (match === "high_contrast") {
        if (maxContrast < 7.0) {
          wcagCompliance = "partial";
          issues.push("High contrast context requires AAA level contrast");
        } else {
          wcagCompliance = "AAA";
        }
      }
      
    }
    
  } else {
    issues.push("Missing primary color token");
    wcagCompliance = "partial";
  }
  return {
          wcagCompliance: wcagCompliance,
          contrastIssues: issues,
          colorBlindnessCompatible: true,
          recommendations: issues.length !== 0 ? ["Consider adjusting lightness values for better contrast"] : []
        };
}

function generateLocalIntelligencePalette(request) {
  try {
    var intelligentPalette = ColorAnalysis.generateIntelligentPalette(request.baseColor, {
          style: request.style
        }, undefined);
    var secondaryColor;
    try {
      var color = Culori.parseToOklch(request.baseColor);
      var oklchCoords = Culori.getOklchCoords(color);
      var h = oklchCoords[2];
      var l = oklchCoords[0];
      var c = oklchCoords[1];
      secondaryColor = Culori.oklchToHex(l, c, (h + 30.0) % 360.0);
    }
    catch (exn){
      secondaryColor = request.baseColor;
    }
    var semanticColors = ColorAnalysis.generateSemanticColorsAI({
          primary: request.baseColor,
          secondary: secondaryColor
        });
    var convertPaletteToTokens = function (palette) {
      var tokens = {};
      var rescriptPalette = palette.palette;
      var steps = [
        "50",
        "100",
        "200",
        "300",
        "400",
        "500",
        "600",
        "700",
        "800",
        "900"
      ];
      Belt_Array.forEach(steps, (function (step) {
              var color;
              switch (step) {
                case "200" :
                    color = rescriptPalette[200];
                    break;
                case "300" :
                    color = rescriptPalette[300];
                    break;
                case "400" :
                    color = rescriptPalette[400];
                    break;
                case "100" :
                case "50" :
                    color = rescriptPalette[100];
                    break;
                case "500" :
                    color = rescriptPalette[500];
                    break;
                case "600" :
                    color = rescriptPalette[600];
                    break;
                case "700" :
                    color = rescriptPalette[700];
                    break;
                case "800" :
                    color = rescriptPalette[800];
                    break;
                case "900" :
                    color = rescriptPalette[900];
                    break;
                default:
                  color = request.baseColor;
              }
              tokens[step] = {
                value: color
              };
            }));
      return tokens;
    };
    var secondaryPalette = ColorAnalysis.generateIntelligentPalette(secondaryColor, {
          style: request.style
        }, undefined);
    var neutralColor;
    try {
      var color$1 = Culori.parseToOklch(request.baseColor);
      var oklchCoords$1 = Culori.getOklchCoords(color$1);
      var h$1 = oklchCoords$1[2];
      neutralColor = Culori.oklchToHex(0.5, 0.05, h$1);
    }
    catch (exn$1){
      neutralColor = "#6b7280";
    }
    var neutralPalette = ColorAnalysis.generateIntelligentPalette(neutralColor, {
          style: "minimal"
        }, undefined);
    var tokens = {
      color: {
        primary: convertPaletteToTokens(intelligentPalette),
        secondary: convertPaletteToTokens(secondaryPalette),
        neutral: convertPaletteToTokens(neutralPalette),
        semantic: {
          success: {
            value: semanticColors.semantic.success
          },
          warning: {
            value: semanticColors.semantic.warning
          },
          error: {
            value: semanticColors.semantic.error
          },
          info: {
            value: semanticColors.semantic.info
          }
        }
      }
    };
    var accessibility = analyzeStyleDictionaryAccessibility(tokens, request);
    var metadata_reasoning = "Algorithmically generated " + paletteStyleToString(request.style) + " palette using advanced color theory";
    var metadata = {
      provider: "Local Intelligence",
      confidence: 0.75,
      reasoning: metadata_reasoning,
      accessibility: accessibility
    };
    var ctx = request.context;
    var metadataWithContext;
    if (ctx !== undefined) {
      var newrecord = Caml_obj.obj_dup(metadata);
      newrecord.context = ctx;
      metadataWithContext = newrecord;
    } else {
      metadataWithContext = metadata;
    }
    return {
            tokens: tokens,
            metadata: metadataWithContext
          };
  }
  catch (exn$2){
    var fallbackTokens = generateFallbackStyleDictionary(request.baseColor);
    var fallbackMetadata_accessibility = {
      wcagCompliance: "partial",
      contrastIssues: ["Error in accessibility analysis"],
      colorBlindnessCompatible: false,
      recommendations: ["Manual review recommended"]
    };
    var fallbackMetadata = {
      provider: "Local Intelligence (Fallback)",
      confidence: 0.5,
      reasoning: "Fallback palette due to processing error",
      accessibility: fallbackMetadata_accessibility
    };
    var ctx$1 = request.context;
    var fallbackMetadataWithContext;
    if (ctx$1 !== undefined) {
      var newrecord$1 = Caml_obj.obj_dup(fallbackMetadata);
      newrecord$1.context = ctx$1;
      fallbackMetadataWithContext = newrecord$1;
    } else {
      fallbackMetadataWithContext = fallbackMetadata;
    }
    return {
            tokens: fallbackTokens,
            metadata: fallbackMetadataWithContext
          };
  }
}

function generateRuleBasedPalette(request) {
  try {
    var baseColor = Culori.parseToOklch(request.baseColor);
    var baseCoords = Culori.getOklchCoords(baseColor);
    var h = baseCoords[2];
    var c = baseCoords[1];
    var generateSimpleScale = function (_color) {
      var tokens = {};
      var steps = [
        50.0,
        100.0,
        200.0,
        300.0,
        400.0,
        500.0,
        600.0,
        700.0,
        800.0,
        900.0
      ];
      Belt_Array.forEach(steps, (function (step) {
              var lightness = 0.95 - step / 1000.0 * 0.9;
              var stepStr = String(step).replace(".0", "");
              var colorHex;
              try {
                colorHex = Culori.oklchToHex(lightness, c, h);
              }
              catch (exn){
                colorHex = request.baseColor;
              }
              tokens[stepStr] = {
                value: colorHex
              };
            }));
      return tokens;
    };
    var secondaryColor;
    try {
      secondaryColor = Culori.oklchToHex(baseCoords[0], c, (h + 30.0) % 360.0);
    }
    catch (exn){
      secondaryColor = request.baseColor;
    }
    var neutralColor;
    try {
      neutralColor = Culori.oklchToHex(0.5, 0.05, h);
    }
    catch (exn$1){
      neutralColor = "#6b7280";
    }
    var tokens = {
      color: {
        primary: generateSimpleScale(request.baseColor),
        secondary: generateSimpleScale(secondaryColor),
        neutral: generateSimpleScale(neutralColor),
        semantic: undefined
      }
    };
    var ruleBasedMetadata_accessibility = {
      wcagCompliance: "AA",
      contrastIssues: [],
      colorBlindnessCompatible: true,
      recommendations: []
    };
    var ruleBasedMetadata = {
      provider: "Rule-Based",
      confidence: 0.6,
      reasoning: "Rule-based palette generation ensuring reliability and accessibility",
      accessibility: ruleBasedMetadata_accessibility
    };
    var ctx = request.context;
    var ruleBasedMetadataWithContext;
    if (ctx !== undefined) {
      var newrecord = Caml_obj.obj_dup(ruleBasedMetadata);
      newrecord.context = ctx;
      ruleBasedMetadataWithContext = newrecord;
    } else {
      ruleBasedMetadataWithContext = ruleBasedMetadata;
    }
    return {
            tokens: tokens,
            metadata: ruleBasedMetadataWithContext
          };
  }
  catch (exn$2){
    var fallbackTokens = generateFallbackStyleDictionary(request.baseColor);
    var ruleBasedFallbackMetadata_accessibility = {
      wcagCompliance: "partial",
      contrastIssues: [],
      colorBlindnessCompatible: true,
      recommendations: []
    };
    var ruleBasedFallbackMetadata = {
      provider: "Rule-Based (Fallback)",
      confidence: 0.4,
      reasoning: "Minimal rule-based fallback palette",
      accessibility: ruleBasedFallbackMetadata_accessibility
    };
    var ctx$1 = request.context;
    var ruleBasedFallbackMetadataWithContext;
    if (ctx$1 !== undefined) {
      var newrecord$1 = Caml_obj.obj_dup(ruleBasedFallbackMetadata);
      newrecord$1.context = ctx$1;
      ruleBasedFallbackMetadataWithContext = newrecord$1;
    } else {
      ruleBasedFallbackMetadataWithContext = ruleBasedFallbackMetadata;
    }
    return {
            tokens: fallbackTokens,
            metadata: ruleBasedFallbackMetadataWithContext
          };
  }
}

export {
  paletteStyleToString ,
  generateLocalIntelligencePalette ,
  generateRuleBasedPalette ,
  analyzeStyleDictionaryAccessibility ,
  generateFallbackStyleDictionary ,
}
/* Culori Not a pure module */
