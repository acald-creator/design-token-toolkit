// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";

function hexToRgb(hex) {
  var cleanHex = hex.length > 0 && hex.startsWith("#") ? hex.slice(1, hex.length) : hex;
  if (cleanHex.length !== 6) {
    return ;
  }
  var rHex = cleanHex.slice(0, 2);
  var gHex = cleanHex.slice(2, 4);
  var bHex = cleanHex.slice(4, 6);
  var parseHex = function (hexStr) {
    var charToInt = function (c) {
      switch (c) {
        case "0" :
            return 0;
        case "1" :
            return 1;
        case "2" :
            return 2;
        case "3" :
            return 3;
        case "4" :
            return 4;
        case "5" :
            return 5;
        case "6" :
            return 6;
        case "7" :
            return 7;
        case "8" :
            return 8;
        case "9" :
            return 9;
        case "A" :
        case "a" :
            return 10;
        case "B" :
        case "b" :
            return 11;
        case "C" :
        case "c" :
            return 12;
        case "D" :
        case "d" :
            return 13;
        case "E" :
        case "e" :
            return 14;
        case "F" :
        case "f" :
            return 15;
        default:
          return ;
      }
    };
    if (hexStr.length !== 2) {
      return ;
    }
    var match = hexStr[0];
    var match$1 = hexStr[1];
    if (match === undefined) {
      return ;
    }
    if (match$1 === undefined) {
      return ;
    }
    var match$2 = charToInt(match);
    var match$3 = charToInt(match$1);
    if (match$2 !== undefined && match$3 !== undefined) {
      return (match$2 << 4) + match$3 | 0;
    }
    
  };
  var match = parseHex(rHex);
  var match$1 = parseHex(gHex);
  var match$2 = parseHex(bHex);
  if (match !== undefined && match$1 !== undefined && match$2 !== undefined) {
    return {
            r: match,
            g: match$1,
            b: match$2
          };
  }
  
}

function rgbToHex(color) {
  var componentToHex = function (c) {
    var hex = c.toString(16);
    if (hex.length === 1) {
      return "0" + hex;
    } else {
      return hex;
    }
  };
  return "#" + componentToHex(color.r) + componentToHex(color.g) + componentToHex(color.b);
}

function rgbToLab(color) {
  var linearize = function (c) {
    var normalized = c / 255.0;
    if (normalized <= 0.04045) {
      return normalized / 12.92;
    } else {
      return Math.pow((normalized + 0.055) / 1.055, 2.4);
    }
  };
  var rLinear = linearize(color.r);
  var gLinear = linearize(color.g);
  var bLinear = linearize(color.b);
  var x = 0.4124564 * rLinear + 0.3575761 * gLinear + 0.1804375 * bLinear;
  var y = 0.2126729 * rLinear + 0.7151522 * gLinear + 0.0721750 * bLinear;
  var z = 0.0193339 * rLinear + 0.1191920 * gLinear + 0.9503041 * bLinear;
  var fx = x / 0.95047 > 0.008856 ? Math.pow(x / 0.95047, 1.0 / 3.0) : 7.787 * (x / 0.95047) + 16.0 / 116.0;
  var fy = y / 1.00000 > 0.008856 ? Math.pow(y / 1.00000, 1.0 / 3.0) : 7.787 * (y / 1.00000) + 16.0 / 116.0;
  var fz = z / 1.08883 > 0.008856 ? Math.pow(z / 1.08883, 1.0 / 3.0) : 7.787 * (z / 1.08883) + 16.0 / 116.0;
  return {
          l: 116.0 * fy - 16.0,
          a: 500.0 * (fx - fy),
          b: 200.0 * (fy - fz)
        };
}

function deltaE76(color1, color2) {
  var lab1 = rgbToLab(color1);
  var lab2 = rgbToLab(color2);
  var deltaL = lab1.l - lab2.l;
  var deltaA = lab1.a - lab2.a;
  var deltaB = lab1.b - lab2.b;
  return Math.sqrt(deltaL * deltaL + deltaA * deltaA + deltaB * deltaB);
}

function calculateRelativeLuminance(color) {
  var sRGB = function (c) {
    var normalized = c / 255.0;
    if (normalized <= 0.03928) {
      return normalized / 12.92;
    } else {
      return Math.pow((normalized + 0.055) / 1.055, 2.4);
    }
  };
  return 0.2126 * sRGB(color.r) + 0.7152 * sRGB(color.g) + 0.0722 * sRGB(color.b);
}

function calculateContrastRatio(color1, color2) {
  var l1 = calculateRelativeLuminance(color1);
  var l2 = calculateRelativeLuminance(color2);
  var lighter = Math.max(l1, l2);
  var darker = Math.min(l1, l2);
  return (lighter + 0.05) / (darker + 0.05);
}

var protanopiaMatrix = [
  [
    0.567,
    0.433,
    0.000
  ],
  [
    0.558,
    0.442,
    0.000
  ],
  [
    0.000,
    0.242,
    0.758
  ]
];

var deuteranopiaMatrix = [
  [
    0.625,
    0.375,
    0.000
  ],
  [
    0.700,
    0.300,
    0.000
  ],
  [
    0.000,
    0.300,
    0.700
  ]
];

var tritanopiaMatrix = [
  [
    0.950,
    0.050,
    0.000
  ],
  [
    0.000,
    0.433,
    0.567
  ],
  [
    0.000,
    0.475,
    0.525
  ]
];

var monochromacyMatrix = [
  [
    0.299,
    0.587,
    0.114
  ],
  [
    0.299,
    0.587,
    0.114
  ],
  [
    0.299,
    0.587,
    0.114
  ]
];

function applyColorBlindnessMatrix(color, matrix) {
  var r = color.r / 255.0;
  var g = color.g / 255.0;
  var b = color.b / 255.0;
  var row0 = matrix[0];
  var row1 = matrix[1];
  var row2 = matrix[2];
  var newR = r * row0[0] + g * row0[1] + b * row0[2];
  var newG = r * row1[0] + g * row1[1] + b * row1[2];
  var newB = r * row2[0] + g * row2[1] + b * row2[2];
  return {
          r: Math.max(0.0, Math.min(255.0, newR * 255.0)) | 0,
          g: Math.max(0.0, Math.min(255.0, newG * 255.0)) | 0,
          b: Math.max(0.0, Math.min(255.0, newB * 255.0)) | 0
        };
}

function simulateColorBlindness(color, blindnessType) {
  switch (blindnessType) {
    case "Deuteranomaly" :
        var simulated = applyColorBlindnessMatrix(color, deuteranopiaMatrix);
        return {
                r: (color.r + simulated.r | 0) / 2 | 0,
                g: (color.g + simulated.g | 0) / 2 | 0,
                b: (color.b + simulated.b | 0) / 2 | 0
              };
    case "Deuteranopia" :
        return applyColorBlindnessMatrix(color, deuteranopiaMatrix);
    case "Monochromacy" :
        return applyColorBlindnessMatrix(color, monochromacyMatrix);
    case "Protanomaly" :
        var simulated$1 = applyColorBlindnessMatrix(color, protanopiaMatrix);
        return {
                r: (color.r + simulated$1.r | 0) / 2 | 0,
                g: (color.g + simulated$1.g | 0) / 2 | 0,
                b: (color.b + simulated$1.b | 0) / 2 | 0
              };
    case "Protanopia" :
        return applyColorBlindnessMatrix(color, protanopiaMatrix);
    case "Tritanomaly" :
        var simulated$2 = applyColorBlindnessMatrix(color, tritanopiaMatrix);
        return {
                r: (color.r + simulated$2.r | 0) / 2 | 0,
                g: (color.g + simulated$2.g | 0) / 2 | 0,
                b: (color.b + simulated$2.b | 0) / 2 | 0
              };
    case "Tritanopia" :
        return applyColorBlindnessMatrix(color, tritanopiaMatrix);
    default:
      return color;
  }
}

function analyzeWCAGCompliance(colors, backgrounds) {
  var results = [];
  var rgbColors = Belt_Array.keepMap(colors, hexToRgb);
  var rgbBackgrounds = Belt_Array.keepMap(backgrounds, hexToRgb);
  for(var i = 0 ,i_finish = rgbBackgrounds.length; i < i_finish; ++i){
    for(var j = 0 ,j_finish = rgbColors.length; j < j_finish; ++j){
      var bg = rgbBackgrounds[i];
      var fg = rgbColors[j];
      var contrast = calculateContrastRatio(fg, bg);
      var analysis_foreground = rgbToHex(fg);
      var analysis_background = rgbToHex(bg);
      var analysis_passesAA = contrast >= 4.5;
      var analysis_passesAAA = contrast >= 7.0;
      var analysis_passesAALarge = contrast >= 3.0;
      var analysis_passesAAALarge = contrast >= 4.5;
      var analysis = {
        foreground: analysis_foreground,
        background: analysis_background,
        ratio: contrast,
        passesAA: analysis_passesAA,
        passesAAA: analysis_passesAAA,
        passesAALarge: analysis_passesAALarge,
        passesAAALarge: analysis_passesAAALarge
      };
      results = Belt_Array.concat(results, [analysis]);
    }
  }
  return results;
}

function analyzeColorBlindnessBatch(colors) {
  var rgbColors = Belt_Array.keepMap(colors, hexToRgb);
  var blindnessTypes = [
    "Protanopia",
    "Deuteranopia",
    "Tritanopia",
    "Monochromacy"
  ];
  var allAffectedColors = {
    contents: []
  };
  var allDistinctionIssues = {
    contents: []
  };
  Belt_Array.forEach(blindnessTypes, (function (blindnessType) {
          var simulatedColors = Belt_Array.map(rgbColors, (function (color) {
                  var simulated = simulateColorBlindness(color, blindnessType);
                  var original = rgbToHex(color);
                  var perceived = rgbToHex(simulated);
                  var difference = deltaE76(color, simulated);
                  return {
                          original: original,
                          perceived: perceived,
                          difference: difference
                        };
                }));
          Belt_Array.forEach(simulatedColors, (function (simColor) {
                  allAffectedColors.contents = Belt_Array.concat(allAffectedColors.contents, [simColor]);
                }));
          for(var i = 0 ,i_finish = simulatedColors.length; i < i_finish; ++i){
            for(var j = i + 1 | 0 ,j_finish = simulatedColors.length; j < j_finish; ++j){
              var color1 = simulatedColors[i];
              var color2 = simulatedColors[j];
              var originalRgb1 = Belt_Array.getExn(rgbColors, i);
              var originalRgb2 = Belt_Array.getExn(rgbColors, j);
              var originalDistance = deltaE76(originalRgb1, originalRgb2);
              var match = hexToRgb(color1.perceived);
              var match$1 = hexToRgb(color2.perceived);
              var perceivedDistance = match !== undefined ? (
                  match$1 !== undefined ? deltaE76(match, match$1) : 0.0
                ) : 0.0;
              var problematic = originalDistance > 10.0 && perceivedDistance < 5.0;
              if (problematic) {
                var issue_color1 = color1.original;
                var issue_color2 = color2.original;
                var issue = {
                  color1: issue_color1,
                  color2: issue_color2,
                  originalDistance: originalDistance,
                  perceivedDistance: perceivedDistance,
                  problematic: problematic
                };
                allDistinctionIssues.contents = Belt_Array.concat(allDistinctionIssues.contents, [issue]);
              }
              
            }
          }
        }));
  var avgDifference;
  if (allAffectedColors.contents.length !== 0) {
    var totalDiff = Belt_Array.reduce(allAffectedColors.contents, 0.0, (function (sum, color) {
            return sum + color.difference;
          }));
    avgDifference = totalDiff / allAffectedColors.contents.length;
  } else {
    avgDifference = 0.0;
  }
  var issueCount = allDistinctionIssues.contents.length;
  var severity = avgDifference < 5.0 && issueCount === 0 ? 100.0 : (
      avgDifference < 15.0 && issueCount <= 2 ? 75.0 : (
          avgDifference < 30.0 && issueCount <= 5 ? 50.0 : 25.0
        )
    );
  return {
          affectedColors: allAffectedColors.contents,
          distinctionIssues: allDistinctionIssues.contents,
          severity: severity
        };
}

function analyzeAccessibilityComprehensive(colors, backgrounds) {
  var validColors = Belt_Array.keep(colors, (function (color) {
          return Belt_Option.isSome(hexToRgb(color));
        }));
  var validBackgrounds = Belt_Array.keep(backgrounds, (function (bg) {
          return Belt_Option.isSome(hexToRgb(bg));
        }));
  if (validColors.length === 0) {
    return {
            overallScore: 50.0,
            wcagCompliance: "None",
            colorBlindnessScore: 50.0,
            contrastIssues: [],
            problematicPairs: []
          };
  }
  var contrastAnalyses = analyzeWCAGCompliance(validColors, validBackgrounds);
  var colorBlindnessAnalysis = analyzeColorBlindnessBatch(validColors);
  var passedAA = Belt_Array.every(contrastAnalyses, (function (analysis) {
          return analysis.passesAA;
        }));
  var passedAAA = Belt_Array.every(contrastAnalyses, (function (analysis) {
          return analysis.passesAAA;
        }));
  var partialAA = Belt_Array.some(contrastAnalyses, (function (analysis) {
          return analysis.passesAA;
        }));
  var wcagLevel = passedAAA ? "AAA" : (
      passedAA ? "AA" : (
          partialAA ? "Partial" : "None"
        )
    );
  var wcagScore;
  switch (wcagLevel) {
    case "AAA" :
        wcagScore = 100.0;
        break;
    case "AA" :
        wcagScore = 85.0;
        break;
    case "Partial" :
        wcagScore = 60.0;
        break;
    case "None" :
        wcagScore = 30.0;
        break;
    
  }
  var colorBlindnessScore = colorBlindnessAnalysis.severity;
  var overallScore = wcagScore * 0.6 + colorBlindnessScore * 0.4;
  var contrastIssues = Belt_Array.keep(contrastAnalyses, (function (analysis) {
          return !analysis.passesAA;
        }));
  return {
          overallScore: overallScore,
          wcagCompliance: wcagLevel,
          colorBlindnessScore: colorBlindnessScore,
          contrastIssues: contrastIssues,
          problematicPairs: colorBlindnessAnalysis.distinctionIssues
        };
}

export {
  hexToRgb ,
  rgbToHex ,
  rgbToLab ,
  deltaE76 ,
  calculateRelativeLuminance ,
  calculateContrastRatio ,
  protanopiaMatrix ,
  deuteranopiaMatrix ,
  tritanopiaMatrix ,
  monochromacyMatrix ,
  applyColorBlindnessMatrix ,
  simulateColorBlindness ,
  analyzeWCAGCompliance ,
  analyzeColorBlindnessBatch ,
  analyzeAccessibilityComprehensive ,
}
/* No side effect */
