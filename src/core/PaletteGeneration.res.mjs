// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";

function rgbToHex(color) {
  var componentToHex = function (c) {
    var hex = c.toString(16);
    if (hex.length === 1) {
      return "0" + hex;
    } else {
      return hex;
    }
  };
  return "#" + componentToHex(color.r) + componentToHex(color.g) + componentToHex(color.b);
}

function hexToRgb(hex) {
  var cleanHex = hex.length > 0 && hex.startsWith("#") ? hex.slice(1, hex.length) : hex;
  if (cleanHex.length !== 6) {
    return ;
  }
  var rHex = cleanHex.slice(0, 2);
  var gHex = cleanHex.slice(2, 4);
  var bHex = cleanHex.slice(4, 6);
  var parseHex = function (hexStr) {
    var charToInt = function (c) {
      switch (c) {
        case "0" :
            return 0;
        case "1" :
            return 1;
        case "2" :
            return 2;
        case "3" :
            return 3;
        case "4" :
            return 4;
        case "5" :
            return 5;
        case "6" :
            return 6;
        case "7" :
            return 7;
        case "8" :
            return 8;
        case "9" :
            return 9;
        case "A" :
        case "a" :
            return 10;
        case "B" :
        case "b" :
            return 11;
        case "C" :
        case "c" :
            return 12;
        case "D" :
        case "d" :
            return 13;
        case "E" :
        case "e" :
            return 14;
        case "F" :
        case "f" :
            return 15;
        default:
          return ;
      }
    };
    if (hexStr.length !== 2) {
      return ;
    }
    var match = hexStr[0];
    var match$1 = hexStr[1];
    if (match === undefined) {
      return ;
    }
    if (match$1 === undefined) {
      return ;
    }
    var match$2 = charToInt(match);
    var match$3 = charToInt(match$1);
    if (match$2 !== undefined && match$3 !== undefined) {
      return (match$2 << 4) + match$3 | 0;
    }
    
  };
  var match = parseHex(rHex);
  var match$1 = parseHex(gHex);
  var match$2 = parseHex(bHex);
  if (match !== undefined && match$1 !== undefined && match$2 !== undefined) {
    return {
            r: match,
            g: match$1,
            b: match$2
          };
  }
  
}

function rgbToHsl(color) {
  var r = color.r / 255.0;
  var g = color.g / 255.0;
  var b = color.b / 255.0;
  var max = Math.max(r, Math.max(g, b));
  var min = Math.min(r, Math.min(g, b));
  var delta = max - min;
  var l = (max + min) / 2.0;
  var s = delta === 0.0 ? 0.0 : (
      l < 0.5 ? delta / (max + min) : delta / (2.0 - max - min)
    );
  var h = delta === 0.0 ? 0.0 : (
      max === r ? 60.0 * ((g - b) / delta % 6.0) : (
          max === g ? 60.0 * ((b - r) / delta + 2.0) : 60.0 * ((r - g) / delta + 4.0)
        )
    );
  return {
          h: h < 0.0 ? h + 360.0 : h,
          s: s,
          l: l
        };
}

function hslToRgb(color) {
  var c = (1.0 - Math.abs(2.0 * color.l - 1.0)) * color.s;
  var x = c * (1.0 - Math.abs(color.h / 60.0 % 2.0 - 1.0));
  var m = color.l - c / 2.0;
  var match = color.h < 60.0 ? [
      c,
      x,
      0.0
    ] : (
      color.h < 120.0 ? [
          x,
          c,
          0.0
        ] : (
          color.h < 180.0 ? [
              0.0,
              c,
              x
            ] : (
              color.h < 240.0 ? [
                  0.0,
                  x,
                  c
                ] : (
                  color.h < 300.0 ? [
                      x,
                      0.0,
                      c
                    ] : [
                      c,
                      0.0,
                      x
                    ]
                )
            )
        )
    );
  return {
          r: (match[0] + m) * 255.0 | 0,
          g: (match[1] + m) * 255.0 | 0,
          b: (match[2] + m) * 255.0 | 0
        };
}

function generateLightnessScale(_baseL, steps) {
  var stepSize = 0.9 / (steps - 1 | 0);
  return Belt_Array.makeBy(steps, (function (i) {
                var normalizedStep = i * stepSize;
                return 0.05 + normalizedStep;
              }));
}

function generateColorPalette(baseColor, _steps) {
  var baseRgb = hexToRgb(baseColor);
  if (baseRgb === undefined) {
    return ;
  }
  var baseHsl = rgbToHsl(baseRgb);
  var lightnessValues = generateLightnessScale(baseHsl.l, 10);
  var paletteArray = Belt_Array.mapWithIndex(lightnessValues, (function (index, lightness) {
          var adjustedHsl_h = baseHsl.h;
          var adjustedHsl_s = baseHsl.s;
          var adjustedHsl = {
            h: adjustedHsl_h,
            s: adjustedHsl_s,
            l: lightness
          };
          var adjustedRgb = hslToRgb(adjustedHsl);
          return [
                  Math.imul(index + 1 | 0, 100),
                  rgbToHex(adjustedRgb)
                ];
        }));
  var palette = Belt_Array.reduce(paletteArray, {}, (function (acc, param) {
          var stepStr = String(param[0]);
          acc[stepStr] = param[1];
          return acc;
        }));
  return {
          "100": Belt_Option.getWithDefault(Js_dict.get(palette, "100"), baseColor),
          "200": Belt_Option.getWithDefault(Js_dict.get(palette, "200"), baseColor),
          "300": Belt_Option.getWithDefault(Js_dict.get(palette, "300"), baseColor),
          "400": Belt_Option.getWithDefault(Js_dict.get(palette, "400"), baseColor),
          "500": Belt_Option.getWithDefault(Js_dict.get(palette, "500"), baseColor),
          "600": Belt_Option.getWithDefault(Js_dict.get(palette, "600"), baseColor),
          "700": Belt_Option.getWithDefault(Js_dict.get(palette, "700"), baseColor),
          "800": Belt_Option.getWithDefault(Js_dict.get(palette, "800"), baseColor),
          "900": Belt_Option.getWithDefault(Js_dict.get(palette, "900"), baseColor),
          "1000": Belt_Option.getWithDefault(Js_dict.get(palette, "1000"), baseColor)
        };
}

function generateHarmoniousPalette(baseColor, harmonyType) {
  var baseRgb = hexToRgb(baseColor);
  if (baseRgb === undefined) {
    return [baseColor];
  }
  var baseHsl = rgbToHsl(baseRgb);
  switch (harmonyType) {
    case "analogous" :
        var colors = [
          hslToRgb({
                h: (baseHsl.h - 30.0 + 360.0) % 360.0,
                s: baseHsl.s,
                l: baseHsl.l
              }),
          baseRgb,
          hslToRgb({
                h: (baseHsl.h + 30.0) % 360.0,
                s: baseHsl.s,
                l: baseHsl.l
              })
        ];
        return Belt_Array.map(colors, rgbToHex);
    case "complementary" :
        var complementaryHsl_h = (baseHsl.h + 180.0) % 360.0;
        var complementaryHsl_s = baseHsl.s;
        var complementaryHsl_l = baseHsl.l;
        var complementaryHsl = {
          h: complementaryHsl_h,
          s: complementaryHsl_s,
          l: complementaryHsl_l
        };
        return [
                rgbToHex(baseRgb),
                rgbToHex(hslToRgb(complementaryHsl))
              ];
    case "monochromatic" :
        var lightnessValues = [
          0.2,
          0.4,
          baseHsl.l,
          0.8
        ];
        return Belt_Array.map(lightnessValues, (function (l) {
                      return rgbToHex(hslToRgb({
                                      h: baseHsl.h,
                                      s: baseHsl.s,
                                      l: l
                                    }));
                    }));
    case "triadic" :
        var triadic1_h = (baseHsl.h + 120.0) % 360.0;
        var triadic1_s = baseHsl.s;
        var triadic1_l = baseHsl.l;
        var triadic1 = {
          h: triadic1_h,
          s: triadic1_s,
          l: triadic1_l
        };
        var triadic2_h = (baseHsl.h + 240.0) % 360.0;
        var triadic2_s = baseHsl.s;
        var triadic2_l = baseHsl.l;
        var triadic2 = {
          h: triadic2_h,
          s: triadic2_s,
          l: triadic2_l
        };
        return [
                rgbToHex(baseRgb),
                rgbToHex(hslToRgb(triadic1)),
                rgbToHex(hslToRgb(triadic2))
              ];
    default:
      return [baseColor];
  }
}

function applyStyleAdjustments(baseHsl, style) {
  switch (style) {
    case "Professional" :
        return baseHsl;
    case "Vibrant" :
        return {
                h: baseHsl.h,
                s: Math.min(1.0, baseHsl.s + 0.2),
                l: Math.min(1.0, baseHsl.l + 0.1)
              };
    case "Minimal" :
        return {
                h: baseHsl.h,
                s: Math.max(0.0, baseHsl.s - 0.1),
                l: Math.min(1.0, baseHsl.l + 0.05)
              };
    case "Warm" :
        return {
                h: baseHsl.h,
                s: Math.min(1.0, baseHsl.s + 0.1),
                l: Math.min(1.0, baseHsl.l + 0.05)
              };
    case "Cool" :
        return {
                h: baseHsl.h,
                s: Math.min(1.0, baseHsl.s + 0.05),
                l: Math.max(0.0, baseHsl.l - 0.05)
              };
    
  }
}

function generateIntelligentPalette(baseColor, options) {
  var baseRgb = hexToRgb(baseColor);
  if (baseRgb === undefined) {
    return ;
  }
  var baseHsl = rgbToHsl(baseRgb);
  var adjustedHsl = applyStyleAdjustments(baseHsl, options.style);
  var adjustedColor = rgbToHex(hslToRgb(adjustedHsl));
  return generateColorPalette(adjustedColor, options.size);
}

function calculateRelativeLuminance(color) {
  var sRGB = function (c) {
    var normalized = c / 255.0;
    if (normalized <= 0.03928) {
      return normalized / 12.92;
    } else {
      return Math.pow((normalized + 0.055) / 1.055, 2.4);
    }
  };
  return 0.2126 * sRGB(color.r) + 0.7152 * sRGB(color.g) + 0.0722 * sRGB(color.b);
}

function calculateContrastRatio(color1, color2) {
  var l1 = calculateRelativeLuminance(color1);
  var l2 = calculateRelativeLuminance(color2);
  var lighter = Math.max(l1, l2);
  var darker = Math.min(l1, l2);
  return (lighter + 0.05) / (darker + 0.05);
}

function validatePaletteAccessibility(palette) {
  var colors = [
    palette[100],
    palette[200],
    palette[300],
    palette[400],
    palette[500],
    palette[600],
    palette[700],
    palette[800],
    palette[900],
    palette[1000]
  ];
  var rgbColors = Belt_Array.keepMap(colors, hexToRgb);
  var accessibleCount = Belt_Array.reduce(rgbColors, 0, (function (count, color) {
          var contrastWhite = calculateContrastRatio(color, {
                r: 255,
                g: 255,
                b: 255
              });
          var contrastBlack = calculateContrastRatio(color, {
                r: 0,
                g: 0,
                b: 0
              });
          var maxContrast = Math.max(contrastWhite, contrastBlack);
          if (maxContrast >= 4.5) {
            return count + 1 | 0;
          } else {
            return count;
          }
        }));
  return accessibleCount / rgbColors.length >= 0.7;
}

export {
  rgbToHex ,
  hexToRgb ,
  rgbToHsl ,
  hslToRgb ,
  generateLightnessScale ,
  generateColorPalette ,
  generateHarmoniousPalette ,
  applyStyleAdjustments ,
  generateIntelligentPalette ,
  calculateRelativeLuminance ,
  calculateContrastRatio ,
  validatePaletteAccessibility ,
}
/* No side effect */
